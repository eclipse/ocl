/*******************************************************************************
 * Copyright (c) 2015 Willink Transformations, University of York and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Adolfo Sanchez-Barbudo Herrera (University of York) - initial API and implementation
 *******************************************************************************/
package org.eclipse.ocl.examples.build.xtend

import java.util.ArrayList
import java.util.List
import org.eclipse.emf.codegen.ecore.genmodel.GenClassifier
import org.eclipse.emf.codegen.ecore.genmodel.GenPackage
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.mwe.core.issues.Issues
import org.eclipse.jdt.annotation.NonNull
import org.eclipse.ocl.examples.autogen.lookup.LookupCGUtil
import org.eclipse.ocl.examples.codegen.generator.AbstractGenModelHelper
import org.eclipse.ocl.examples.codegen.generator.GenModelHelper
import org.eclipse.ocl.pivot.Class
import org.eclipse.ocl.pivot.Operation
import org.eclipse.ocl.pivot.Type
import org.eclipse.ocl.pivot.internal.manager.PivotMetamodelManager
import org.eclipse.ocl.pivot.internal.utilities.PivotUtilInternal
import org.eclipse.ocl.pivot.utilities.ClassUtil
import org.eclipse.ocl.pivot.utilities.EnvironmentFactory
import org.eclipse.ocl.pivot.CollectionType

public class GenerateAutoLookupInfrastructureXtend extends GenerateAutoLookupVisitors
{
	// The lookupVisitor will be in the normal visitors folder, but all the artifacts generated by this compoenent
	// will be in a different one
	String lookupArtifactsJavaPackage;
	String lookupArtifactsOutputFolder;
	String lookupPackageName
	String superLookupPackageName
	GenModelHelper genModel;
	
	
	override checkConfiguration(Issues issues) {
		super.checkConfiguration(issues);
		if (this.lookupPackageName.length() == 0 ) {
			issues.addError(this, "lookupPackageName must be specified");
		}
	}

	public def setLookupPackageName(String lookupPackageName) {
		this.lookupPackageName = lookupPackageName;
	}
	
	public def setSuperLookupPackageName(String superLookupPackageName) {
		this.superLookupPackageName = superLookupPackageName;
	}
	
	protected def void generateAutoLookupResultItf(@NonNull EPackage ePackage) {
		var boolean isDerived = isDerived();
		if (!isDerived) {
			var MergeWriter writer = new MergeWriter(lookupArtifactsOutputFolder + projectPrefix + "LookupResult.java");
			writer.append('''
	«ePackage.generateHeader(lookupArtifactsJavaPackage)»
	
	import java.util.List;
	
	import org.eclipse.jdt.annotation.NonNull;
	import org.eclipse.jdt.annotation.Nullable;
	
	/**
	 * The lookup result returned by the name lookup solver
	 */
	public interface «projectPrefix»LookupResult<NE> {
	
		@Nullable
		NE getSingleResult();
		
		@NonNull
		List<NE> getAllResults();
		
		int size();
	}
			''');
			writer.close();
		}
	}
	
	protected def void generateAutoLookupResultClass(@NonNull EPackage ePackage) {
		var boolean isDerived = isDerived();
		if (!isDerived) {
			var MergeWriter writer = new MergeWriter(lookupArtifactsOutputFolder + projectPrefix + "LookupResultImpl.java");
			writer.append('''
	«ePackage.generateHeader(lookupArtifactsJavaPackage)»
	
	import java.util.ArrayList;
	import java.util.Collections;
	import java.util.List;
	
	import org.eclipse.jdt.annotation.NonNull;
	import org.eclipse.jdt.annotation.Nullable;
	
	public class «projectPrefix»LookupResultImpl<NE> implements «projectPrefix»LookupResult<NE> {
		
		private List<NE> results = new ArrayList<NE>();
		
		public «projectPrefix»LookupResultImpl(List<NE> results){
			this.results.addAll(results);
		}
		
		@SuppressWarnings("null")
		@Override
		@NonNull
		public List<NE> getAllResults() {
			return Collections.unmodifiableList(results);
		}
		
		@Override
		@Nullable
		public NE getSingleResult() {
			return results.size() == 0 ? null : results.get(0);
		}
		
		@Override
		public int size() {
			return results.size();
		}
	}
			''');
			writer.close();
		}
	}
	
	protected def void generateAutoLookupFilter(@NonNull EPackage ePackage) {
		val boolean isDerived = isDerived();
		if (!isDerived) {
			val itfName =  projectPrefix + "LookupFilter"
			val MergeWriter writer = new MergeWriter(lookupArtifactsOutputFolder + itfName + ".java");
			writer.append('''
	«ePackage.generateHeader(lookupArtifactsJavaPackage)»
	
	import «modelPackageName».NamedElement;

	/**
	 * 
	 */
	public interface «itfName» {
		
		boolean matches(NamedElement namedElement);
		
	}
			''');
			writer.close();
		}
	}
	protected def void generateSingleResultLookupEnvironment(@NonNull EPackage ePackage) { 
		
		var boolean isDerived = isDerived();
		var className = projectPrefix + "SingleResultLookupEnvironment";
		if (!isDerived) {
			var MergeWriter writer = new MergeWriter(lookupArtifactsOutputFolder + className+ ".java");
			writer.append('''
	«ePackage.generateHeader(lookupArtifactsJavaPackage)»
	
	import java.util.ArrayList;
	import java.util.List;
	
	import org.eclipse.emf.common.util.EList;
	import org.eclipse.emf.ecore.EClass;
	import org.eclipse.jdt.annotation.NonNull;
	import org.eclipse.jdt.annotation.Nullable;
	import org.eclipse.ocl.pivot.evaluation.Executor;
	
	import «modelPackageName».NamedElement;
	import «lookupPackageName».LookupEnvironment;
	import «lookupPackageName».impl.LookupEnvironmentImpl;
	
	public class «className» extends LookupEnvironmentImpl   {
		
		private @NonNull Executor executor;
		private @NonNull String name;
		private @NonNull EClass typeFilter;
		private @NonNull «projectPrefix»LookupFilter expFilter;
		
		public «className»(@NonNull Executor executor, @NonNull EClass typeFilter, @NonNull String name, «projectPrefix»LookupFilter expFilter) {
			this.executor = executor;
			this.name = name;
			this.typeFilter = typeFilter;
			this.expFilter = expFilter;
		}
	
		public ClassesSingleResultLookupEnvironment(@NonNull Executor executor, @NonNull EClass typeFilter, @NonNull String name) {
			this(executor,typeFilter, name, null);
		}
		
		@Override
		@NonNull
		public Executor getExecutor() {
			return executor;
		}
		
		@Override
		public boolean hasFinalResult() {
			for (NamedElement element : getNamedElements()) {
				if (name.equals(element.getName())) {
					return true;
				}
			}
			return false;
		}
		
		@Override
		@NonNull
		public LookupEnvironment addElement(@Nullable NamedElement namedElement) {
			if (namedElement != null) {
				if (name.equals(namedElement.getName())) {
					if (typeFilter.isInstance(namedElement)) {
						if (expFilter == null || expFilter.matches(namedElement)) {
							EList<NamedElement> elements = getNamedElements();
							if (!elements.contains(namedElement)) { 	// FIXME use a set ?
								elements.add(namedElement);
							}
						}
					}
				}
			}
			return this;
		}
		
		@Override
		@NonNull
		public <NE extends NamedElement > LookupEnvironment addElements(
				@Nullable EList<NE> namedElements) {
			
			if (namedElements != null) {
				for (NamedElement namedElement : namedElements) {
					addElement(namedElement);
				}	
			}
			return this;
		}
		
		@SuppressWarnings("unchecked")
		public <NE extends NamedElement> List<NE> getNamedElementsByKind(Class<NE> class_) {
			List<NE> result = new ArrayList<NE>(); 
			for (NamedElement namedElement : getNamedElements()) {
				if (class_.isAssignableFrom(namedElement.getClass())) {
					result.add((NE)namedElement);
				}
			}
			return result;
		}
	}
			''');
			writer.close();
		}
	}
	
	protected def void generateUnqualifiedLookupVisitor(@NonNull EPackage ePackage) { 
		
		var boolean isDerived = isDerived();
		var className = projectPrefix + "UnqualifiedLookupVisitor";
		if (!isDerived) {
			var MergeWriter writer = new MergeWriter(lookupArtifactsOutputFolder + className+ ".java");
			writer.append('''
	«ePackage.generateHeader(lookupArtifactsJavaPackage)»
	
	import org.eclipse.jdt.annotation.NonNull;
	import «lookupPackageName».LookupEnvironment;
	import «visitorPackageName».Abstract«className»;
	
	public class «className» extends Abstract«className» {
	
		public «className»(@NonNull LookupEnvironment context) {
			super(context);
		}
	
	}
			''');
			writer.close();
		}
	}
	
	protected def void generateQualifiedLookupVisitor(@NonNull EPackage ePackage) { 
		
		var boolean isDerived = isDerived();
		var className = projectPrefix + "QualifiedLookupVisitor";
		if (!isDerived) {
			var MergeWriter writer = new MergeWriter(lookupArtifactsOutputFolder + className+ ".java");
			writer.append('''
	«ePackage.generateHeader(lookupArtifactsJavaPackage)»
	
	import org.eclipse.jdt.annotation.NonNull;
	import «lookupPackageName».LookupEnvironment;
	import «visitorPackageName».Abstract«className»;
	
	public class «className» extends Abstract«className» {
	
		public «className»(@NonNull LookupEnvironment context) {
			super(context);
		}
	
	}
			''');
			writer.close();
		}
	}
	
	protected def void generateExportedLookupVisitor(@NonNull EPackage ePackage) { 
		
		var boolean isDerived = isDerived();
		var className = projectPrefix + "ExportedLookupVisitor";
		if (!isDerived) {
			var MergeWriter writer = new MergeWriter(lookupArtifactsOutputFolder + className+ ".java");
			writer.append('''
	«ePackage.generateHeader(lookupArtifactsJavaPackage)»
	
	import org.eclipse.jdt.annotation.NonNull;
	import «lookupPackageName».LookupEnvironment;
	import «visitorPackageName».Abstract«className»;
	
	public class «className» extends Abstract«className» {
	
		public «className»(@NonNull LookupEnvironment context, @NonNull Object importer) {
			super(context, importer);
		}
	
	}
			''');
			writer.close();
		}
	}
	
	protected def void generateAutoLookupSolver(@NonNull GenPackage genPackage) {
		var EPackage ePackage = genPackage.getEcorePackage;
		var String fqPackageItf = genModel.getQualifiedPackageInterfaceName(ePackage)
		var List<Operation> lookupOps = genPackage.lookupMethods;
		var boolean isDerived = isDerived();
		var String className = projectPrefix + "LookupSolver";
		var String superClassName = superProjectPrefix + "LookupSolver";
		var MergeWriter writer = new MergeWriter(lookupArtifactsOutputFolder + className + ".java");
		writer.append('''
	«ePackage.generateHeader(lookupArtifactsJavaPackage)»

	import org.eclipse.ocl.pivot.evaluation.Executor;
	«IF isDerived»import «superLookupPackageName».util.«superClassName»;«ENDIF»
	
	public class «className»«IF isDerived» extends «superClassName»«ENDIF» {
		
		private Executor executor;
			
		public «className» (Executor executor) {
			this.executor = executor;
		}
		
		«FOR op : lookupOps»
		«val opName = op.name»
		«val isExportedLookup = op.exportedLookupOperation»
		«val lookupVisitorName = op.getLookupVisitorName»
		«val hasAdditionalFilter = op.hasAdditionalFilterArgs»
		«val lookupVars = op.getLookupArgs»
		«val typeFQName = getTypeFQName(op.type)»
		«val typeLiteral = getTypeLiteral(op.type)»
		
		public «projectPrefix»LookupResult<«typeFQName»> «opName»(«getTypeFQName(op.owningClass)» context«FOR param:op.ownedParameters», «getTypeFQName(param.type)» «param.name»«ENDFOR») {
			«IF hasAdditionalFilter»
			«op.type.name»Filter filter = new «op.type.name»Filter(«op.getFilterArgs»);
			«ENDIF»
			«projectPrefix»SingleResultLookupEnvironment _lookupEnv = new «projectPrefix»SingleResultLookupEnvironment(executor, «fqPackageItf».Literals.«typeLiteral»«lookupVars»);
			«lookupVisitorName» _lookupVisitor = new «lookupVisitorName»(_lookupEnv«IF isExportedLookup», importer«ENDIF»);
			context.accept(_lookupVisitor);
			return new «projectPrefix»LookupResultImpl<«typeFQName»>
					(_lookupEnv.getNamedElementsByKind(«typeFQName».class));
		}
		«ENDFOR»
	}
		''');
		writer.close();
	}
	
	override generateVisitors(GenPackage genPackage) {
		super.generateVisitors(genPackage);
		
		genModel = createGenModelHelper(genPackage);
		lookupArtifactsJavaPackage = lookupPackageName + ".util";
		lookupArtifactsOutputFolder = modelFolder + lookupArtifactsJavaPackage.replace('.', '/') + "/";
		
		var EPackage ePackage = genPackage.getEcorePackage();
		
		ePackage.generateAutoLookupResultClass;
		ePackage.generateAutoLookupResultItf;
		ePackage.generateSingleResultLookupEnvironment;
		ePackage.generateUnqualifiedLookupVisitor;
		ePackage.generateQualifiedLookupVisitor;
		ePackage.generateExportedLookupVisitor;
		genPackage.generateAutoLookupSolver;
	}

	protected def List<Operation> getLookupMethods(GenPackage genPackage) {
		
		var List<Operation> result = new ArrayList<Operation>;
		var EnvironmentFactory envFact = PivotUtilInternal.getEnvironmentFactory(genPackage.getEcorePackage.eResource);		
		for (oclPackage : LookupCGUtil.getTargetPackages(genPackage, envFact, lookupFilePath, projectName, projectPrefix)) {
			for (oclClass : oclPackage.ownedClasses) {
				for (oclOp : oclClass.ownedOperations) {
					if (oclOp.isLookupOperation) {
						result.add(oclOp);
					}
				}
			}
		} 
		return result;
	}
		
	private def boolean isLookupOperation(Operation op){
		// internal lookup ops...
		if (!op.name.startsWith("_lookup")) {
			return false;
		}
	
		// ...which don't have the env parameter
		// FIXME more robust check of the parameter
		for (param : op.ownedParameters) {
			if ("env".equals(param.name)) {
				return false
			}
		}
		
		return true;
	}
	
	private def boolean isExportedLookupOperation(Operation op) {
		isLookupOperation(op) && op.name.contains("Exported") // FIXME more robust check?
	}
	
	private def GenModelHelper createGenModelHelper(GenPackage genPackage) {
		var PivotMetamodelManager mManager = PivotUtilInternal.getEnvironmentFactory(genPackage.getEcorePackage().eResource).metamodelManager;
		return new AbstractGenModelHelper(mManager);
	}
	
	private def String getTypeLiteral(Type type) {
		var GenClassifier genClassifier = genModel.getGenClassifier(type as Class);
		return ClassUtil.nonNullState(genClassifier).classifierID; 
	}
	
	private def String getTypeFQName(Type type) {
		return if (type instanceof CollectionType) '''java.util.List<«getTypeFQName(type.elementType)»>''' 
			else genModel.getEcoreInterfaceName(type as Class)	
	}
	
	private def String getLookupVisitorName(Operation op) {
		if (op.name.contains("Qualified")) '''«projectPrefix»QualifiedLookupVisitor'''
		else if (op.name.contains("Exported")) '''«projectPrefix»ExportedLookupVisitor'''
		else '''«projectPrefix»UnqualifiedLookupVisitor''';	
	}

	
	private def boolean hasAdditionalFilterArgs(Operation op) {
		val params = op.ownedParameters;
		if (op.isExportedLookupOperation) params.size() > 2 else params.size() > 1;
	}
	
	private def String getLookupArgs(Operation op) {
		val params = op.ownedParameters
		val nameParam = if (op.isExportedLookupOperation) params.get(1) else params.get(0);
		''',«nameParam.name»«IF op.hasAdditionalFilterArgs»,filter«ENDIF»'''
	}
	
	// We assume we are dealing with the the exported element lookup op
	private def String getFilterArgs(Operation op) {
		val sb = new StringBuffer();
		val filterArgsIndex = if (op.isExportedLookupOperation) 2 else 1;
		val params = op.ownedParameters
		var first=true;
		for (var i = filterArgsIndex; i < params.size; i++) {
			if (first) {
				first = false
			} else {
				sb.append(',');	
			}
			sb.append('''«params.get(i).name»''');
		}
		sb.toString();
	}
	
}
